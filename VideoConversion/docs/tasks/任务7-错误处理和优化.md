# 任务7：错误处理和优化

## 📋 任务概述

建立完善的错误处理机制和性能优化策略，确保应用的稳定性和用户体验。

## 🎯 任务目标

- [ ] 实现全局错误处理系统
- [ ] 添加性能优化措施
- [ ] 建立错误恢复机制
- [ ] 优化用户体验

## 📝 详细任务清单

### 步骤7.1：实现全局错误处理

#### 任务清单
- [ ] 创建错误分类系统
- [ ] 实现错误恢复机制
- [ ] 添加故障排除建议
- [ ] 设置错误日志记录

#### 实现代码
```javascript
// 全局错误处理初始化
function initializeErrorHandling() {
    console.log('🛡️ 初始化错误处理系统...');
    
    // 设置全局错误监听器
    window.addEventListener('error', handleGlobalError);
    window.addEventListener('unhandledrejection', handleUnhandledRejection);
    
    // 设置页面卸载清理
    window.addEventListener('beforeunload', cleanupResources);
    
    // 初始化错误报告系统
    initializeErrorReporting();
}

// 全局错误处理器
function handleGlobalError(event) {
    console.error('全局错误:', event.error);
    
    const error = event.error;
    const context = event.filename ? `${event.filename}:${event.lineno}` : '未知位置';
    
    handleError(error, context, { global: true });
}

// 未处理的Promise拒绝
function handleUnhandledRejection(event) {
    console.error('未处理的Promise拒绝:', event.reason);
    
    handleError(event.reason, 'Promise拒绝', { promise: true });
    event.preventDefault(); // 防止默认的错误处理
}

// 统一错误处理函数
function handleError(error, context, options = {}) {
    console.error(`错误发生在 ${context}:`, error);
    
    // 错误分类处理
    const errorType = classifyError(error);
    
    switch (errorType) {
        case 'NetworkError':
            handleNetworkError(error, context, options);
            break;
        case 'ValidationError':
            handleValidationError(error, context, options);
            break;
        case 'ServerError':
            handleServerError(error, context, options);
            break;
        case 'TimeoutError':
            handleTimeoutError(error, context, options);
            break;
        case 'SignalRError':
            handleSignalRError(error, context, options);
            break;
        default:
            handleGenericError(error, context, options);
    }
    
    // 记录错误到控制台和可能的日志服务
    logError(error, context, errorType);
}

// 错误分类
function classifyError(error) {
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
        return 'NetworkError';
    }
    if (error.name === 'ValidationError' || error.status === 400) {
        return 'ValidationError';
    }
    if (error.status >= 500) {
        return 'ServerError';
    }
    if (error.name === 'TimeoutError' || error.code === 'TIMEOUT') {
        return 'TimeoutError';
    }
    if (error.message && error.message.includes('SignalR')) {
        return 'SignalRError';
    }
    return 'GenericError';
}

// 网络错误处理
function handleNetworkError(error, context, options) {
    showAlert('warning', '网络连接问题，请检查网络后重试');
    
    // 尝试重新连接SignalR
    if (context.includes('SignalR')) {
        setTimeout(() => {
            console.log('尝试重新连接SignalR...');
            startConnection();
        }, 5000);
    }
    
    // 显示网络诊断建议
    showNetworkDiagnostics();
}

// 验证错误处理
function handleValidationError(error, context, options) {
    const message = error.message || '输入数据验证失败';
    showAlert('warning', `验证错误: ${message}`);
    
    // 高亮相关的表单字段
    highlightErrorFields(error);
}

// 服务器错误处理
function handleServerError(error, context, options) {
    const message = error.message || '服务器内部错误';
    showAlert('danger', `服务器错误: ${message}`);
    
    // 显示重试选项
    showRetryOption(context, error);
}

// 超时错误处理
function handleTimeoutError(error, context, options) {
    showAlert('warning', '操作超时，请重试');
    
    // 自动重试机制
    if (options.autoRetry !== false) {
        scheduleRetry(context, error);
    }
}

// SignalR错误处理
function handleSignalRError(error, context, options) {
    showAlert('warning', 'SignalR连接异常，正在尝试恢复...');
    
    // 重新建立连接
    setTimeout(() => {
        startConnection();
    }, 2000);
}

// 通用错误处理
function handleGenericError(error, context, options) {
    const message = error.message || '发生未知错误';
    showAlert('danger', `错误: ${message}`);
    
    // 提供用户反馈选项
    showErrorFeedbackOption(error, context);
}
```

### 步骤7.2：实现性能优化

#### 任务清单
- [ ] 添加防抖和节流机制
- [ ] 优化DOM操作
- [ ] 实现内存管理
- [ ] 优化网络请求

#### 实现代码
```javascript
// 性能优化工具类
class PerformanceOptimizer {
    constructor() {
        this.debounceTimers = new Map();
        this.throttleTimers = new Map();
        this.observedElements = new WeakSet();
    }
    
    // 防抖函数
    debounce(func, delay, key) {
        if (this.debounceTimers.has(key)) {
            clearTimeout(this.debounceTimers.get(key));
        }
        
        const timer = setTimeout(() => {
            func();
            this.debounceTimers.delete(key);
        }, delay);
        
        this.debounceTimers.set(key, timer);
    }
    
    // 节流函数
    throttle(func, delay, key) {
        if (this.throttleTimers.has(key)) {
            return;
        }
        
        func();
        
        const timer = setTimeout(() => {
            this.throttleTimers.delete(key);
        }, delay);
        
        this.throttleTimers.set(key, timer);
    }
    
    // 批量DOM更新
    batchDOMUpdates(updates) {
        requestAnimationFrame(() => {
            updates.forEach(update => update());
        });
    }
    
    // 虚拟滚动优化
    optimizeScrolling(container, itemHeight, renderItem) {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    renderItem(entry.target);
                }
            });
        });
        
        container.querySelectorAll('.scroll-item').forEach(item => {
            observer.observe(item);
        });
        
        return observer;
    }
    
    // 内存清理
    cleanup() {
        this.debounceTimers.forEach(timer => clearTimeout(timer));
        this.throttleTimers.forEach(timer => clearTimeout(timer));
        this.debounceTimers.clear();
        this.throttleTimers.clear();
    }
}

// 创建性能优化器实例
const performanceOptimizer = new PerformanceOptimizer();

// 优化文件上传进度更新
const optimizedUpdateUploadProgress = (data) => {
    performanceOptimizer.throttle(() => {
        updateUploadProgress(data);
    }, 100, 'uploadProgress');
};

// 优化任务进度更新
const optimizedUpdateProgress = (data) => {
    performanceOptimizer.throttle(() => {
        updateProgress(data);
    }, 200, 'taskProgress');
};

// 优化GPU状态更新
const optimizedUpdateGpuStatus = (data) => {
    performanceOptimizer.throttle(() => {
        gpuMonitor.displayGpuStatus(data);
    }, 1000, 'gpuStatus');
};

// 优化搜索功能
function optimizedSearch(query, callback) {
    performanceOptimizer.debounce(() => {
        callback(query);
    }, 300, 'search');
}

// 批量更新任务列表
function batchUpdateTaskList(tasks) {
    const updates = tasks.map(task => () => {
        updateRecentTaskProgress(task.id, task.progress);
    });
    
    performanceOptimizer.batchDOMUpdates(updates);
}
```

### 步骤7.3：实现错误恢复机制

#### 任务清单
- [ ] 创建自动重试机制
- [ ] 实现状态恢复
- [ ] 添加用户引导
- [ ] 建立故障转移

#### 实现代码
```javascript
// 错误恢复管理器
class ErrorRecoveryManager {
    constructor() {
        this.retryAttempts = new Map();
        this.maxRetries = 3;
        this.retryDelay = 1000;
        this.recoveryStrategies = new Map();
        
        this.initializeRecoveryStrategies();
    }
    
    // 初始化恢复策略
    initializeRecoveryStrategies() {
        // SignalR连接恢复
        this.recoveryStrategies.set('signalr_connection', {
            maxRetries: 5,
            delay: 2000,
            strategy: async () => {
                await startConnection();
                return connection.state === signalR.HubConnectionState.Connected;
            }
        });
        
        // 文件上传恢复
        this.recoveryStrategies.set('file_upload', {
            maxRetries: 3,
            delay: 1000,
            strategy: async (context) => {
                const { file, formData } = context;
                return await handleLargeFileUpload(file, formData);
            }
        });
        
        // GPU检测恢复
        this.recoveryStrategies.set('gpu_detection', {
            maxRetries: 2,
            delay: 3000,
            strategy: async () => {
                await loadGpuInfo();
                return document.getElementById('gpuInfo').innerHTML.includes('GPU');
            }
        });
    }
    
    // 执行恢复策略
    async executeRecovery(strategyKey, context = null) {
        const strategy = this.recoveryStrategies.get(strategyKey);
        if (!strategy) {
            console.error(`未找到恢复策略: ${strategyKey}`);
            return false;
        }
        
        const attemptKey = `${strategyKey}_${Date.now()}`;
        let attempts = 0;
        
        while (attempts < strategy.maxRetries) {
            try {
                console.log(`执行恢复策略 ${strategyKey}, 尝试 ${attempts + 1}/${strategy.maxRetries}`);
                
                const result = await strategy.strategy(context);
                
                if (result) {
                    console.log(`恢复策略 ${strategyKey} 执行成功`);
                    this.retryAttempts.delete(attemptKey);
                    return true;
                }
            } catch (error) {
                console.error(`恢复策略 ${strategyKey} 执行失败:`, error);
            }
            
            attempts++;
            
            if (attempts < strategy.maxRetries) {
                await this.delay(strategy.delay * attempts);
            }
        }
        
        console.error(`恢复策略 ${strategyKey} 最终失败`);
        this.retryAttempts.delete(attemptKey);
        return false;
    }
    
    // 延迟函数
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // 自动恢复
    async autoRecover(errorType, context = null) {
        const strategyMap = {
            'SignalRError': 'signalr_connection',
            'NetworkError': 'signalr_connection',
            'UploadError': 'file_upload',
            'GpuError': 'gpu_detection'
        };
        
        const strategyKey = strategyMap[errorType];
        if (strategyKey) {
            return await this.executeRecovery(strategyKey, context);
        }
        
        return false;
    }
}

// 创建错误恢复管理器实例
const errorRecoveryManager = new ErrorRecoveryManager();

// 显示网络诊断建议
function showNetworkDiagnostics() {
    const diagnosticsHtml = `
        <div class="alert alert-info alert-dismissible fade show">
            <h6><i class="fas fa-network-wired"></i> 网络诊断建议</h6>
            <ul class="mb-2">
                <li>检查网络连接是否正常</li>
                <li>尝试刷新页面</li>
                <li>检查防火墙设置</li>
                <li>联系网络管理员</li>
            </ul>
            <button type="button" class="btn btn-outline-primary btn-sm" onclick="location.reload()">
                <i class="fas fa-redo"></i> 刷新页面
            </button>
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
    `;
    
    const container = document.querySelector('.container-fluid');
    container.insertAdjacentHTML('afterbegin', diagnosticsHtml);
}

// 显示重试选项
function showRetryOption(context, error) {
    const retryHtml = `
        <div class="alert alert-warning alert-dismissible fade show">
            <h6><i class="fas fa-exclamation-triangle"></i> 操作失败</h6>
            <p class="mb-2">操作失败，您可以尝试以下选项：</p>
            <button type="button" class="btn btn-outline-primary btn-sm me-2" onclick="retryLastOperation('${context}')">
                <i class="fas fa-redo"></i> 重试
            </button>
            <button type="button" class="btn btn-outline-secondary btn-sm" onclick="reportError('${error.message}')">
                <i class="fas fa-bug"></i> 报告问题
            </button>
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
    `;
    
    const container = document.querySelector('.container-fluid');
    container.insertAdjacentHTML('afterbegin', retryHtml);
}

// 重试最后操作
async function retryLastOperation(context) {
    console.log('重试操作:', context);
    
    // 根据上下文执行相应的重试逻辑
    switch (context) {
        case 'file_upload':
            const form = document.getElementById('conversionForm');
            if (form) {
                form.dispatchEvent(new Event('submit'));
            }
            break;
        case 'signalr_connection':
            await startConnection();
            break;
        case 'gpu_detection':
            await loadGpuInfo();
            break;
        default:
            location.reload();
    }
}

// 资源清理
function cleanupResources() {
    console.log('🧹 清理页面资源...');
    
    // 清理定时器
    if (window.taskTimer) {
        clearInterval(window.taskTimer);
    }
    
    // 停止GPU监控
    if (typeof gpuMonitor !== 'undefined') {
        gpuMonitor.stopMonitoring();
    }
    
    // 清理性能优化器
    if (typeof performanceOptimizer !== 'undefined') {
        performanceOptimizer.cleanup();
    }
    
    // 断开SignalR连接
    if (connection && connection.state === signalR.HubConnectionState.Connected) {
        try {
            if (currentTaskId) {
                connection.invoke("LeaveTaskGroup", currentTaskId);
            }
            connection.stop();
        } catch (error) {
            console.error('关闭SignalR连接时出错:', error);
        }
    }
}

// 错误日志记录
function logError(error, context, errorType) {
    const errorLog = {
        timestamp: new Date().toISOString(),
        context: context,
        type: errorType,
        message: error.message,
        stack: error.stack,
        userAgent: navigator.userAgent,
        url: window.location.href,
        userId: getCurrentUserId(), // 如果有用户系统
        sessionId: getSessionId() // 如果有会话系统
    };
    
    console.error('错误日志:', errorLog);
    
    // 发送到日志服务（可选）
    sendErrorToLoggingService(errorLog);
}

// 发送错误到日志服务
async function sendErrorToLoggingService(errorLog) {
    try {
        await fetch('/api/logging/error', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(errorLog)
        });
    } catch (error) {
        console.error('发送错误日志失败:', error);
    }
}

// 获取当前用户ID（示例）
function getCurrentUserId() {
    // 实现获取当前用户ID的逻辑
    return 'anonymous';
}

// 获取会话ID（示例）
function getSessionId() {
    // 实现获取会话ID的逻辑
    return sessionStorage.getItem('sessionId') || 'unknown';
}

// 报告错误
function reportError(errorMessage) {
    // 实现错误报告功能
    console.log('报告错误:', errorMessage);
    showAlert('info', '错误报告已提交，感谢您的反馈！');
}

// 初始化错误报告系统
function initializeErrorReporting() {
    // 可以集成第三方错误报告服务
    console.log('错误报告系统已初始化');
}
```

## ✅ 验收标准

### 功能验收
- [ ] 全局错误处理正常工作
- [ ] 性能优化措施有效
- [ ] 错误恢复机制可靠
- [ ] 资源清理完整

### 稳定性验收
- [ ] 各种错误场景处理正确
- [ ] 内存泄漏检查通过
- [ ] 长时间运行稳定
- [ ] 错误恢复成功率高

### 用户体验验收
- [ ] 错误提示友好明确
- [ ] 恢复过程用户感知良好
- [ ] 性能优化效果明显
- [ ] 操作响应及时

## 🔗 依赖关系

### 前置依赖
- 所有前面的任务模块

### 后续任务
- 任务8：测试和部署

## 📊 预估工时

- **开发时间**: 4-5小时
- **测试时间**: 3小时
- **总计**: 7-8小时

## 🚨 注意事项

1. **错误分类**: 准确分类不同类型的错误
2. **性能影响**: 错误处理不应影响正常性能
3. **用户体验**: 错误提示应该友好且有指导性
4. **隐私保护**: 错误日志不应包含敏感信息

## 📝 完成标记

- [ ] 步骤7.1完成
- [ ] 步骤7.2完成
- [ ] 步骤7.3完成
- [ ] 验收测试通过
- [ ] 代码提交完成

**完成时间**: ___________  
**开发者**: ___________  
**审核者**: ___________
